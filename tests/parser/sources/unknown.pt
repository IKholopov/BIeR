
"list_element" "[[ptr x 1], [i1 x 1]]"

func append_slice (ptr %sliced_list, i64 %from, i1 %from_present, i64 %to, i1 %to_present, ptr %target_list) ptr
func append_int_element (ptr %list, i64 %value) void
func terminate () void
func get_any_element (ptr %list, i64 %index, ptr %any) ptr
func allocate_list () ptr
func read () i64
func append_list_element (ptr %list, ptr %value) void
func print_list (ptr %) ptr
func append_any_element (ptr %list, ptr %value) void
func print (i64 %) i64
func get_list_element (ptr %list, i64 %index) ptr
func len (ptr %list) i64
func get_int_element (ptr %list, i64 %index) i64
func concat_lists (ptr %left_list, ptr %right_list) void

func first_two (ptr %l, ptr %present_list) ptr {
func_entry:
	%any_element_ptr ptr = alloc_layout @list_elementi64 1
	%any_element ptr = call (ptr,i64,ptr)ptr %get_any_element, ptr %l, i64 0, ptr %any_element_ptr
	call (ptr,ptr)void %append_any_element, ptr %present_list, ptr %any_element
	%any_element_ptr0 ptr = alloc_layout @list_elementi64 1
	%any_element0 ptr = call (ptr,i64,ptr)ptr %get_any_element, ptr %l, i64 1, ptr %any_element_ptr0
	%any_element_ptr1 ptr = alloc_layout @list_elementi64 1
	%any_element1 ptr = call (ptr,i64,ptr)ptr %get_any_element, ptr %l, i64 0, ptr %any_element_ptr1
	%is_list_element_list i1* = gep "" "[[i8* x 1], [i1 x 1]]" idx 1 ptr %any_element0
	%is_list i1 = load i1* %is_list_element_list
	%is_list_element_list0 i1* = gep "" "[[i8* x 1], [i1 x 1]]" idx 1 ptr %any_element1
	%is_list0 i1 = load i1* %is_list_element_list0
	%if_diff_type i1 = ne i1 %is_list, i1 %is_list0
	cond i1 %if_diff_type if_then, if_else
if_then:
	call ()void %terminate
	branch  if_merge
if_else:
	branch  if_merge
if_merge:
	%cond_int i1 = eq i1 %is_list, i1 0
	cond i1 %cond_int if_then0, if_else0
if_then0:
	%left_int_ptr ptr* = gep @list_element idx 0 ptr %any_element0
	%reft_int_ptr ptr* = gep @list_element idx 0 ptr %any_element1
	%0 ptr = load ptr* %left_int_ptr
	%1 ptr = load ptr* %reft_int_ptr
	%2 i32 = load ptr %1
	%3 i32 = load ptr %0
	%addtmp i32 = add i32 %3, i32 %2
	%4 i32* = alloc i64 1
	store i32 %addtmp, i32* %4
	%5 i64 = cast i32* %4
	%value_ptr ptr* = gep @list_element idx 0 ptr %any_element0
	%void_ptr ptr = cast ptr* %value_ptr
	%is_list_ptr i1* = gep @list_element idx 1 ptr %any_element0
	store i64 %5, ptr %void_ptr
	store i1 0, i1* %is_list_ptr
	branch  if_merge0
if_else0:
	call (ptr,ptr)void %concat_lists, ptr %any_element0, ptr %any_element1
	%list_int i64 = cast ptr %any_element0
	%value_ptr0 ptr* = gep @list_element idx 0 ptr %any_element0
	%void_ptr0 ptr = cast ptr* %value_ptr0
	%is_list_ptr0 i1* = gep @list_element idx 1 ptr %any_element0
	store i64 %list_int, ptr %void_ptr0
	store i1 1, i1* %is_list_ptr0
	branch  if_merge0
if_merge0:
	call (ptr,ptr)void %append_any_element, ptr %present_list, ptr %any_element0
	ret ptr %present_list
}

func main () i64 {
func_entry:
	%listalloc ptr = call ()ptr %allocate_list
	%listalloc0 ptr = call ()ptr %allocate_list
	%calluser_list ptr = call (ptr)ptr %user_list, ptr %listalloc0
	%callfirst_two ptr = call (ptr,ptr)ptr %first_two, ptr %calluser_list, ptr %listalloc
	%calllen i64 = call (ptr)i64 %len, ptr %callfirst_two
	%callprint i64 = call (i64)i64 %print, i64 %calllen
	ret i64 %callprint
}

func user_list (ptr %present_list) ptr {
func_entry:
	%callread i64 = call ()i64 %read
	%callarange ptr = call (i64,ptr)ptr %arange, i64 %callread, ptr %present_list
	ret ptr %callarange
}

func arange (i64 %n, ptr %present_list) ptr {
func_entry:
	%eqtmp i1 = eq i64 %n, i64 1
	%if_cmp i1 = ne i1 %eqtmp, i1 0
	cond i1 %if_cmp if_then, if_else
if_then:
	call (ptr,i64)void %append_int_element, ptr %present_list, i64 0
	$if_result ptr = assign ptr %present_list
	branch  if_merge
if_else:
	%subtmp i64 = sub i64 %n, i64 1
	%callarange ptr = call (i64,ptr)ptr %arange, i64 %subtmp, ptr %present_list
	%subtmp0 i64 = sub i64 %n, i64 1
	call (ptr,i64)void %append_int_element, ptr %present_list, i64 %subtmp0
	$if_result ptr = assign ptr %present_list
	branch  if_merge
if_merge:
	ret ptr $if_result
}

